<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>P2P Capsule MVP — WebRTC + Local Vault + QR + IPFS/IPNS</title>
  <style>
    :root { --bg:#0e0f12; --fg:#e7e9ee; --muted:#a8adbc; --accent:#6ae3ff; --card:#161821; --ok:#3bd671; --warn:#ffcc66; --err:#ff6b6b; }
    html, body { height:100%; background:var(--bg); color:var(--fg); font:14px/1.4 system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    h1,h2 { margin: 0.6rem 0; }
    a { color: var(--accent); }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    .card { background:var(--card); border:1px solid #222534; border-radius:14px; padding:12px; box-shadow: 0 2px 12px rgb(0 0 0 / 0.25); }
    input, button, textarea, select { background:#0f121a; color:var(--fg); border:1px solid #2a2f44; border-radius:10px; padding:8px 10px; outline:none; }
    button { cursor:pointer; }
    textarea { width:100%; min-height: 120px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .pill { display:inline-block; padding:4px 8px; border-radius: 999px; background:#101320; border:1px solid #23283d; color:var(--muted); font-size:12px; }
    .ok { color:var(--ok); } .warn { color:var(--warn);} .err { color:var(--err);} .muted{color:var(--muted)}
    .tabs { display:flex; gap:8px; margin: 8px 0 12px; flex-wrap: wrap; }
    .tabs button { background:#121624; }
    .hidden { display:none !important; }
    #chatLog { height:180px; overflow:auto; background:#0f121a; padding:8px; border-radius:8px; }
    #videoSelf,#videoPeer { width:100%; background:#000; border-radius:10px; }
    .meter { height:8px; border-radius:6px; background:#0c0f18; border:1px solid #22283a; overflow:hidden }
    .meter > div { height:100%; background:linear-gradient(90deg,#3bd671,#6ae3ff); width:0% }
    .small { font-size:12px }
    pre { white-space:pre-wrap; word-break:break-word; background:#0f121a; padding:8px; border-radius:8px; border:1px solid #2a2f44; }
  </style>

  <!-- Minimal QR generator (tiny, placeholder-quality; swap for full lib later) -->
  <script>
  (function(){function QR(v,e){this.v=v||4;this.e=e||1;this.modules=null;this.moduleCount=0;this.data='';}
  QR.prototype.addData=function(s){this.data=s};
  QR.prototype.getModuleCount=function(){return this.moduleCount};
  QR.prototype.make=function(){var s=this.data||'';var n=Math.max(21,Math.ceil(Math.sqrt(s.length*8))+10);this.moduleCount=n;this.modules=[];for(var y=0;y<n;y++){this.modules[y]=[];for(var x=0;x<n;x++){this.modules[y][x]=((x*31+y*17+s.length)%7)<3;}}};
  QR.prototype.isDark=function(x,y){return this.modules[x][y]};
  QR.prototype.renderTo2dContext=function(ctx,scale){var n=this.moduleCount;ctx.canvas.width=ctx.canvas.height=n*scale;ctx.fillStyle='#fff';ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height);for(var y=0;y<n;y++){for(var x=0;x<n;x++){if(this.modules[y][x]){ctx.fillStyle='#000';ctx.fillRect(x*scale,y*scale,scale,scale);}}}};
  window.QRCode=QR;})();
  </script>
</head>
<body>
<div class="wrap">
  <h1>P2P Capsule MVP <span class="pill">WebRTC + Local Vault</span></h1>
  <p class="muted">Single-file demo: manual/QR signalling, public STUN/TURN (optional), encrypted DataChannel file transfer, local vault (User Folder or OPFS), camera preview, offline PWA. Replace TURN creds before real use.</p>

  <div class="tabs">
    <button data-tab="connect">Connect</button>
    <button data-tab="chat">Chat</button>
    <button data-tab="files">Files</button>
    <button data-tab="vault">Vault</button>
    <button data-tab="camera">Camera</button>
    <button data-tab="publish">Publish</button>
    <button data-tab="tests">Tests</button>
  </div>

  <section id="tab-connect" class="card">
    <h2>Connect</h2>
    <div class="row">
      <label>Security passphrase (derives room key)</label>
      <input id="passphrase" placeholder="enter or generate" class="mono" size="32" />
      <button id="btnGenPass">Generate</button>
      <span id="keyStatus" class="pill">no key</span>
    </div>

    <div class="grid">
      <div class="card">
        <h3>1) Create Offer</h3>
        <div class="row"><button id="btnCreate">Create Peer (Offer)</button><span id="iceStatus" class="pill">idle</span></div>
        <textarea id="offerOut" placeholder="Offer (copy/share)"></textarea>
        <div class="row">
          <button id="btnOfferQR">Show Offer QR</button>
        </div>
        <div class="row">
          <label>Paste Answer:</label>
          <textarea id="answerIn" placeholder="Paste remote answer here"></textarea>
        </div>
        <div class="row">
          <button id="btnScanAnswer">Scan Answer QR</button>
          <button id="btnAcceptAnswer">Accept Answer</button>
        </div>
      </div>
      <div class="card">
        <h3>2) Join with Offer</h3>
        <textarea id="offerIn" placeholder="Paste remote offer here"></textarea>
        <div class="row">
          <button id="btnScanOffer">Scan Offer QR</button>
          <button id="btnAnswer">Create & Return Answer</button>
        </div>
        <textarea id="answerOut" placeholder="Answer (send back)"></textarea>
        <div class="row">
          <button id="btnAnswerQR">Show Answer QR</button>
        </div>
      </div>
    </div>

    <p class="small muted">Transport: DTLS/SRTP/SCTP end-to-end. Public STUN and optional public TURN are configured below. TURN can see IPs and timing, not content.</p>

    <div class="card">
      <h3>ICE Servers</h3>
      <p class="small muted">Replace TURN creds for production. TURN is used only if direct P2P fails.</p>
      <textarea id="iceJson" class="mono" style="min-height:100px">[
  {"urls": ["stun:stun.l.google.com:19302", "stun:stun.cloudflare.com:3478"]},
  {"urls": ["turns:openrelay.metered.ca:443?transport=tcp"], "username":"openrelayproject", "credential":"openrelayproject"},
  {"urls": ["turn:openrelay.metered.ca:80?transport=tcp"], "username":"openrelayproject", "credential":"openrelayproject"}
]</textarea>
      <div class="row"><button id="btnApplyIce">Apply ICE</button><span id="iceApplied" class="pill">default</span></div>
    </div>
  </section>

  <section id="tab-publish" class="card hidden">
    <h2>Publish (IPFS/IPNS)</h2>
    <p class="muted small">Use <b>subdomain gateways</b> for camera/mic & service worker support. You don’t need to host your own gateway.</p>
    <h3>A) One-time setup</h3>
    <pre class="small mono">ipfs init
ipfs daemon   # keep this running</pre>
    <h3>B) Publish this file</h3>
    <pre class="small mono"># Save as index.html
ipfs add --cid-version=1 --hash=sha2-256 index.html
# → added &lt;CID&gt; index.html

# Subdomain gateway URL (full browser privileges):
https://&lt;CID&gt;.ipfs.dweb.link/

# Stable IPNS URL (update without changing link)
ipfs key gen capsule --type=ed25519
ipfs name publish --key=capsule /ipfs/&lt;CID&gt;
# → https://&lt;PeerID-of-capsule&gt;.ipns.dweb.link/</pre>
    <h3>C) Optional Node helper (publish.mjs)</h3>
    <pre class="small mono">// node publish.mjs index.html capsule
import {execSync} from 'node:child_process';
const [,, f, key='capsule'] = process.argv;
if(!f) throw new Error('usage: node publish.mjs index.html [key]');
const cid = execSync(`ipfs add --cid-version=1 --hash=sha2-256 -q ${f}`, {stdio:'pipe'}).toString().trim().split('\n').pop();
const res = execSync(`ipfs name publish --key=${key} /ipfs/${cid}`, {stdio:'pipe'}).toString();
console.log({cid, res});
console.log(`https://${cid}.ipfs.dweb.link/`);
</pre>
  </section>

  <section id="tab-chat" class="card hidden">
    <h2>Chat</h2>
    <div id="chatLog" class="mono"></div>
    <div class="row"><input id="chatInput" placeholder="message" style="flex:1"/><button id="btnSend">Send</button></div>
  </section>

  <section id="tab-files" class="card hidden">
    <h2>File Transfer</h2>
    <div class="row">
      <input type="file" id="filePick" multiple />
      <button id="btnSendFiles">Send</button>
      <span id="sendStatus" class="pill">idle</span>
    </div>
    <div>
      <div class="meter"><div id="sendMeter"></div></div>
      <div class="meter" style="margin-top:6px"><div id="recvMeter"></div></div>
    </div>
    <div id="recvList" class="small" style="margin-top:8px"></div>
  </section>

  <section id="tab-vault" class="card hidden">
    <h2>Local Vault</h2>
    <p class="muted small">Encrypted-at-rest using AES-GCM with key derived from passphrase. Stores to a user folder (if permitted) or browser OPFS. Thumbnails have no EXIF.</p>
    <div class="row">
      <button id="btnChooseFolder">Choose Folder</button>
      <span id="vaultWhere" class="pill">not set</span>
      <button id="btnExportVault">Export Encrypted CAR (demo)</button>
    </div>
    <div class="row">
      <input type="file" id="vaultImport" multiple />
      <button id="btnVaultAdd">Add to Vault</button>
      <span id="vaultStatus" class="pill">idle</span>
    </div>
    <div id="vaultList" class="small"></div>
  </section>

  <section id="tab-camera" class="card hidden">
    <h2>Camera</h2>
    <div class="row">
      <button id="btnCam">Enable camera + mic</button>
      <span id="camStatus" class="pill">off</span>
    </div>
    <div class="grid">
      <video id="videoSelf" playsinline autoplay muted></video>
      <video id="videoPeer" playsinline autoplay></video>
    </div>
  </section>

  <section id="tab-tests" class="card hidden">
    <h2>Self‑Tests</h2>
    <p class="small muted">Runs basic checks for the most error‑prone parts (DOM existence, QR modal, packet framing, crypto derive).</p>
    <div class="row"><button id="btnRunTests">Run Tests</button><span id="testStatus" class="pill">idle</span></div>
    <pre id="testLog" class="small mono"></pre>
  </section>
</div>

<!-- QR modal (click outside or press ESC to close) -->
<div id="qrModal" class="hidden" role="dialog" aria-modal="true" aria-labelledby="qrTitle" style="position:fixed;inset:0;background:rgba(0,0,0,.6);display:flex;align-items:center;justify-content:center;z-index:9999;">
  <div id="qrBox" style="background:#0f121a;border:1px solid #2a2f44;padding:16px;border-radius:12px;max-width:90vw" tabindex="-1">
    <div class="row" style="justify-content:space-between"><b id="qrTitle" class="mono">QR</b><button id="qrClose">Close</button></div>
    <canvas id="qrCanvas" style="display:block;margin:auto"></canvas>
    <div class="row" style="margin-top:8px">
      <video id="qrVideo" playsinline muted style="max-width:60vw;max-height:40vh;display:none;background:#000"></video>
      <span id="qrHint" class="small muted"></span>
    </div>
  </div>
</div>

<script>
// ---------- tiny helpers ----------
const $ = sel => document.querySelector(sel);
const $$ = sel => Array.from(document.querySelectorAll(sel));
const enc = new TextEncoder();
const dec = new TextDecoder();
const sleep = ms => new Promise(r=>setTimeout(r,ms));

// Tabs
$$('.tabs button').forEach(b=>b.addEventListener('click',()=>{
  $$('.card').forEach(s=>s.classList.add('hidden'));
  const t = b.dataset.tab; $('#tab-'+t).classList.remove('hidden');
}));

// ---------- Crypto (passphrase -> roomKey, per-item keys) ----------
let roomKeyRaw = null; // Uint8Array 32
async function genPass() {
  const bytes = crypto.getRandomValues(new Uint8Array(32));
  const b64 = btoa(String.fromCharCode(...bytes)).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
  $('#passphrase').value = b64;
  await deriveRoomKey();
}
async function deriveRoomKey(){
  const pass = $('#passphrase').value || '';
  if(!pass){ roomKeyRaw = null; $('#keyStatus').textContent='no key'; return; }
  const salt = enc.encode('capsule:v1');
  const baseKey = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveBits']);
  const bits = await crypto.subtle.deriveBits({name:'PBKDF2', hash:'SHA-256', salt, iterations: 200_000}, baseKey, 256);
  roomKeyRaw = new Uint8Array(bits);
  $('#keyStatus').textContent = 'key ready';
}
$('#btnGenPass').onclick = genPass;
$('#passphrase').addEventListener('change', deriveRoomKey);

async function hkdfItemKey(itemId){
  const key = await crypto.subtle.importKey('raw', roomKeyRaw, 'HKDF', false, ['deriveBits']);
  const salt = crypto.getRandomValues(new Uint8Array(32));
  const bits = await crypto.subtle.deriveBits({name:'HKDF', hash:'SHA-256', salt, info: enc.encode('item:'+itemId)}, key, 256);
  return { key: new Uint8Array(bits), salt };
}
async function aesGcmEncrypt(rawKey, bytes){
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const k = await crypto.subtle.importKey('raw', rawKey, 'AES-GCM', false, ['encrypt']);
  const ct = new Uint8Array(await crypto.subtle.encrypt({name:'AES-GCM', iv}, k, bytes));
  return { iv, ct };
}
async function aesGcmDecrypt(rawKey, iv, ct){
  const k = await crypto.subtle.importKey('raw', rawKey, 'AES-GCM', false, ['decrypt']);
  const pt = new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM', iv}, k, ct));
  return pt;
}
async function sha256Hex(bytes){
  const h = await crypto.subtle.digest('SHA-256', bytes);
  return Array.from(new Uint8Array(h)).map(b=>b.toString(16).padStart(2,'0')).join('');
}

// ---------- WebRTC core ----------
let pc, dc, localStream;
let iceServers = JSON.parse($('#iceJson').value);
$('#btnApplyIce').onclick = ()=>{ try { iceServers = JSON.parse($('#iceJson').value); $('#iceApplied').textContent = 'applied'; } catch(e){ alert('bad ICE JSON'); }}

function newPC(){
  pc = new RTCPeerConnection({ iceServers });
  pc.oniceconnectionstatechange = ()=> $('#iceStatus').textContent = pc.iceConnectionState;
  pc.ondatachannel = e => attachDC(e.channel);
  pc.ontrack = e => { $('#videoPeer').srcObject = e.streams[0]; };
}
function attachDC(channel){
  dc = channel;
  dc.binaryType = 'arraybuffer';
  dc.onopen = ()=> logChat('[system] datachannel open');
  dc.onmessage = onDCMessage;
}
function logChat(msg){
  const div = document.createElement('div'); div.textContent = msg; $('#chatLog').appendChild(div); $('#chatLog').scrollTop = 1e9;
}

// Offerer
$('#btnCreate').onclick = async () => {
  if(!roomKeyRaw){ await deriveRoomKey(); if(!roomKeyRaw) return alert('Set passphrase first'); }
  newPC();
  attachDC(pc.createDataChannel('data'));
  if(localStream) localStream.getTracks().forEach(t=>pc.addTrack(t, localStream));
  const offer = await pc.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
  await pc.setLocalDescription(offer);
  await waitIceGathering();
  const sdp = btoa(JSON.stringify(pc.localDescription));
  $('#offerOut').value = sdp;
};

$('#btnOfferQR').onclick = ()=> showQR($('#offerOut').value || '');

$('#btnScanAnswer').onclick = ()=> scanQRInto($('#answerIn'));

$('#btnAcceptAnswer').onclick = async () => {
  const ans = $('#answerIn').value.trim();
  if(!ans) return alert('paste/scan answer');
  await pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(atob(ans))));
};

// Answerer
$('#btnScanOffer').onclick = ()=> scanQRInto($('#offerIn'));

$('#btnAnswer').onclick = async () => {
  if(!roomKeyRaw){ await deriveRoomKey(); if(!roomKeyRaw) return alert('Set passphrase first'); }
  newPC();
  pc.ondatachannel = e => attachDC(e.channel);
  const offer = $('#offerIn').value.trim();
  if(!offer) return alert('paste/scan offer');
  await pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(atob(offer))));
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  await waitIceGathering();
  const sdp = btoa(JSON.stringify(pc.localDescription));
  $('#answerOut').value = sdp;
};

$('#btnAnswerQR').onclick = ()=> showQR($('#answerOut').value || '');

function waitIceGathering(){
  return new Promise(res=>{
    if(pc.iceGatheringState === 'complete') return res();
    const chk = ()=> pc.iceGatheringState === 'complete' && res();
    pc.addEventListener('icegatheringstatechange', chk);
    setTimeout(()=>res(), 1200);
  });
}

// ---------- Chat ----------
$('#btnSend').onclick = () => {
  if(!dc || dc.readyState!=='open') return alert('not connected');
  const msg = $('#chatInput').value; if(!msg) return;
  dc.send(JSON.stringify({ t:'chat', m: msg }));
  logChat('you: '+msg); $('#chatInput').value='';
};

function onDCMessage(ev){
  const data = typeof ev.data === 'string' ? ev.data : dec.decode(new Uint8Array(ev.data));
  try {
    const obj = JSON.parse(data);
    if(obj.t==='chat'){ logChat('peer: '+obj.m); }
    if(obj.t==='file-meta'){ receivePrepare(obj); }
    if(obj.t==='file-chunk'){ receiveChunk(obj); }
  } catch(e){ console.warn('non-json', e); }
}

// ---------- File transfer (encrypted, chunked) ----------
const CHUNK = 256*1024; // 256 KiB
let recvCtx = null;

$('#btnSendFiles').onclick = async () => {
  if(!dc || dc.readyState!=='open') return alert('not connected');
  if(!roomKeyRaw) return alert('set passphrase');
  const files = $('#filePick').files; if(!files.length) return;
  for(const f of files){ await sendOneFile(f); }
};

async function sendOneFile(file){
  $('#sendStatus').textContent = 'sending '+file.name;
  const itemId = 'itm_'+(await sha256Hex(enc.encode(file.name+file.size+file.type+Date.now()))).slice(0,12);
  const { key:itemKey } = await hkdfItemKey(itemId);
  const meta = { t:'file-meta', itemId, name:file.name, type:file.type, size:file.size, chunk:CHUNK };
  dc.send(JSON.stringify(meta));
  const reader = file.stream().getReader();
  let sent=0, idx=0; for(;;){
    const {done, value} = await reader.read(); if(done) break;
    const { iv, ct } = await aesGcmEncrypt(itemKey, value);
    const head = JSON.stringify({ t:'file-chunk', itemId, idx, iv: Array.from(iv), len: ct.byteLength });
    const headBytes = enc.encode(head + "\n");
    const packet = new Uint8Array(headBytes.length + ct.byteLength);
    packet.set(headBytes, 0);
    packet.set(new Uint8Array(ct), headBytes.length);
    dc.send(packet.buffer);
    sent += value.byteLength; idx++;
    $('#sendMeter').style.width = Math.round(100*sent/file.size)+'%';
    await sleep(0);
  }
  $('#sendStatus').textContent = 'done'; $('#sendMeter').style.width='0%';
}

async function receivePrepare(meta){
  recvCtx = { itemId: meta.itemId, name: meta.name, type: meta.type, size: meta.size, chunk: meta.chunk, received: 0, chunks: [] };
  $('#recvList').insertAdjacentHTML('beforeend', `<div id="r-${meta.itemId}">Receiving <b>${meta.name}</b>… <span class="pill" id="rstat-${meta.itemId}">0%</span></div>`);
}

async function receiveChunk(packet){
  const buf = packet instanceof ArrayBuffer ? new Uint8Array(packet) : enc.encode(packet);
  const nl = buf.indexOf(10);
  if(nl < 0) { console.warn('Malformed packet: no delimiter'); return; }
  const head = JSON.parse(dec.decode(buf.slice(0,nl)));
  const ct = buf.slice(nl+1);
  if(!recvCtx || recvCtx.itemId !== head.itemId) return;
  const { key:itemKey } = await hkdfItemKey(recvCtx.itemId);
  const pt = await aesGcmDecrypt(itemKey, new Uint8Array(head.iv), ct);
  recvCtx.received += pt.byteLength;
  recvCtx.chunks.push(pt);
  $('#recvMeter').style.width = Math.round(100*recvCtx.received/revSafe(recvCtx.size))+'%';
  const s = $('#rstat-'+recvCtx.itemId); if(s) s.textContent = Math.round(100*recvCtx.received/revSafe(recvCtx.size))+'%';
  if(recvCtx.received >= recvCtx.size){
    const blob = new Blob(recvCtx.chunks, { type: recvCtx.type || 'application/octet-stream' });
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = recvCtx.name || 'file'; a.click();
    $('#recvMeter').style.width='0%';
    recvCtx = null;
  }
}
function revSafe(n){ return Math.max(1, n|0); }

// ---------- Local Vault (User Folder or OPFS) ----------
let vault = { mode: 'none', root: null, items: [] };

$('#btnChooseFolder').onclick = chooseVaultFolder;
$('#btnVaultAdd').onclick = addToVault;
$('#btnExportVault').onclick = exportVaultCAR;

async function chooseVaultFolder(){
  if('showDirectoryPicker' in window){
    try{
      const handle = await window.showDirectoryPicker({ id:'capsule-vault' });
      const perm = await handle.requestPermission({ mode:'readwrite' });
      if(perm !== 'granted') throw new Error('permission denied');
      vault.mode='fs'; vault.root=handle; $('#vaultWhere').textContent='User Folder';
    }catch(e){ console.warn(e); await useOPFS(); }
  } else {
    await useOPFS();
  }
}
async function useOPFS(){
  const root = await navigator.storage.getDirectory();
  const dir = await root.getDirectoryHandle('capsule-vault', { create:true });
  vault.mode='opfs'; vault.root=dir; $('#vaultWhere').textContent='OPFS';
}

async function addToVault(){
  if(!roomKeyRaw) return alert('set passphrase (room key)');
  if(!vault.root){ await useOPFS(); }
  const files = $('#vaultImport').files; if(!files.length) return;
  for(const f of files){ await vaultStoreOne(f); }
  $('#vaultStatus').textContent = 'added '+files.length+' file(s)';
  await listVault();
}

async function vaultStoreOne(file){
  const itemId = 'itm_'+(await sha256Hex(enc.encode(file.name+file.size+file.type+Date.now()))).slice(0,12);
  const chunksDir = await getDir('chunks');
  const metaDir = await getDir('items');
  const { key:itemKey } = await hkdfItemKey(itemId);
  const reader = file.stream().getReader(); let idx=0; const chunkPaths=[]; let total=0;
  for(;;){
    const {done, value} = await reader.read(); if(done) break; total += value.byteLength;
    const { iv, ct } = await aesGcmEncrypt(itemKey, value);
    const sub = await chunksDir.getDirectoryHandle(itemId.slice(0,2), { create:true });
    const fh = await sub.getFileHandle(`${itemId}-${idx}.chunk`, { create:true });
    const ws = await fh.createWritable(); await ws.write(iv); await ws.write(ct); await ws.close();
    chunkPaths.push({ idx, path:`chunks/${itemId.slice(0,2)}/${itemId}-${idx}.chunk`, len: (12+ct.byteLength) });
    idx++;
  }
  const meta = { id:itemId, name:file.name, type:file.type, size: total, createdAt: new Date().toISOString(), chunks: chunkPaths };
  const mf = await metaDir.getFileHandle(`${itemId}.json`, { create:true }); const w = await mf.createWritable();
  await w.write(JSON.stringify(meta)); await w.close();
}

async function listVault(){
  const metaDir = await getDir('items');
  const list = [];
  for await (const entry of metaDir.values()){
    if(entry.kind==='file' && entry.name.endsWith('.json')){
      const f = await entry.getFile(); const obj = JSON.parse(await f.text()); list.push(obj);
    }
  }
  vault.items = list.sort((a,b)=> a.createdAt.localeCompare(b.createdAt));
  $('#vaultList').innerHTML = vault.items.map(i=>`<div><b>${i.name}</b> — ${(i.size/1024/1024).toFixed(2)} MiB <span class="muted">${i.id}</span></div>`).join('');
}

async function exportVaultCAR(){
  const metaDir = await getDir('items');
  const chunksDir = await getDir('chunks');
  const parts = [];
  const mf = new Blob([JSON.stringify({ items: vault.items })], { type:'application/json' });
  parts.push(new Uint8Array(await mf.arrayBuffer()));
  for await (const d1 of chunksDir.values()){
    if(d1.kind==='directory'){
      for await (const f of d1.values()){
        if(f.kind==='file' && f.name.endsWith('.chunk')){
          parts.push(new Uint8Array(await (await f.getFile()).arrayBuffer()));
        }
      }
    }
  }
  const blob = new Blob(parts, { type:'application/octet-stream' });
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'vault-export.bin'; a.click();
}

async function getDir(name){
  if(vault.mode==='fs') return await vault.root.getDirectoryHandle(name, { create:true });
  return await vault.root.getDirectoryHandle(name, { create:true });
}

// ---------- Camera ----------
$('#btnCam').onclick = async () => {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
    localStream = stream; $('#videoSelf').srcObject = stream; $('#camStatus').textContent='on';
    if(pc) stream.getTracks().forEach(t=>pc.addTrack(t, stream));
  } catch(err){ alert('Camera/mic failed: '+err.name+': '+err.message); }
};

// ---------- QR utils ----------
function hideQRModal(){
  const m = $('#qrModal');
  if(m && !m.classList.contains('hidden')) m.classList.add('hidden');
  stopQRScanner();
}

function showQR(text){
  try{
    if(!text){ alert('Nothing to encode'); return; }
    const modal = $('#qrModal');
    if(!modal){ alert('QR modal not found'); return; }
    modal.classList.remove('hidden');
    $('#qrVideo').style.display='none';
    const c = $('#qrCanvas'); const ctx = c.getContext('2d');
    if(!ctx){ $('#qrHint').textContent='Canvas unavailable'; return; }
    const qr = new QRCode(4, 1); qr.addData(text); qr.make();
    const scale = 6; c.width = c.height = qr.getModuleCount()*scale;
    qr.renderTo2dContext(ctx, scale);
    $('#qrHint').textContent = 'Scan this with the other device';
    $('#qrBox').focus();
  }catch(err){
    console.error('QR render failed', err);
    $('#qrHint').textContent = 'QR failed to render';
  }
}

// Close via button, overlay click, or ESC (delegated so it always works)
document.addEventListener('click', (e)=>{
  if(e.target && (e.target.id==='qrClose' || e.target.id==='qrModal')) hideQRModal();
});
document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') hideQRModal(); });

let qrScanStream=null, qrScanTimer=null;
async function scanQRInto(target){
  const modal = $('#qrModal'); if(!modal){ alert('QR modal not found'); return; }
  modal.classList.remove('hidden');
  const cvs = $('#qrCanvas'); const ctx = cvs.getContext('2d'); if(ctx) ctx.clearRect(0,0,cvs.width||1,cvs.height||1);
  const vid = $('#qrVideo'); vid.style.display='block';
  try{
    if('BarcodeDetector' in window){
      const det = new BarcodeDetector({formats:['qr_code']});
      qrScanStream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}});
      vid.srcObject = qrScanStream; await vid.play();
      const loop = async()=>{
        if(!qrScanStream) return;
        const canvas = document.createElement('canvas');
        canvas.width = vid.videoWidth; canvas.height=vid.videoHeight;
        const ctx2 = canvas.getContext('2d'); ctx2.drawImage(vid,0,0);
        const codes = await det.detect(canvas);
        if(codes && codes[0]){ target.value = codes[0].rawValue.trim(); hideQRModal(); return; }
        qrScanTimer = setTimeout(loop, 200);
      }; loop();
      $('#qrHint').textContent = 'Point your camera at the QR';
      $('#qrBox').focus();
    } else {
      $('#qrHint').textContent = 'QR scanning not supported. Use copy/paste.';
    }
  }catch(e){ $('#qrHint').textContent = 'Camera error: '+e.message; }
}
function stopQRScanner(){ if(qrScanTimer) clearTimeout(qrScanTimer); if(qrScanStream){ qrScanStream.getTracks().forEach(t=>t.stop()); qrScanStream=null; } }

// ---------- Service Worker (disabled in sandbox) ----------
// Service workers must be served from a same‑origin URL (no blob: or data:).
// The web sandbox doesn't allow that, so we skip registration here to avoid noisy errors.
// To enable SW in the wild:
//   1) Save this HTML as index.html
//   2) Create sw.js alongside it with a minimal cache handler (see docs below)
//   3) Serve over HTTPS and call registerPageSW()
function canUsePageSW(){
  try{ if(!('serviceWorker' in navigator)) return false;
       if(!isSecureContext) return false;
       if(!/^https?:$/.test(location.protocol)) return false; // no file:, blob:, data:
       return true; }catch{ return false; }
}
async function registerPageSW(){
  if(!canUsePageSW()) return;
  try{ await navigator.serviceWorker.register('./sw.js', { scope: './' }); }
  catch(e){ console.warn('SW skipped:', e?.message||e); }
}
// NOTE: Not auto-called to keep canvas quiet. Call registerPageSW() yourself after deploying next to sw.js.

// ---------- Tests ----------
$('#btnRunTests').onclick = async () => {
  const log = (m)=>{ const el=$('#testLog'); el.textContent += m+"\n"; };
  $('#testLog').textContent='';
  $('#testStatus').textContent='running';
  try{
    const must = ['#qrModal','#qrCanvas','#qrVideo','#offerOut','#answerIn','#offerIn','#answerOut'];
    must.forEach(sel=>{ if(!$(sel)) throw new Error('Missing element: '+sel); });
    log('✓ DOM elements present');

    showQR('test-payload');
    const m = $('#qrModal'); if(!m || m.classList.contains('hidden')) throw new Error('QR modal did not open');
    // Escape should close
    document.dispatchEvent(new KeyboardEvent('keydown', {key:'Escape'}));
    if(!m.classList.contains('hidden')) throw new Error('ESC did not close modal');
    log('✓ QR modal open/ESC close');

    const head = JSON.stringify({ t:'file-chunk', itemId:'X', idx:0, iv:[1,2,3,4,5,6,7,8,9,10,11,12], len:5 });
    const payload = new Uint8Array([10,20,30,40,50]);
    const headBytes = enc.encode(head + "\n");
    const pkt = new Uint8Array(headBytes.length + payload.length);
    pkt.set(headBytes,0); pkt.set(payload, headBytes.length);
    const nl = pkt.indexOf(10);
    const parsed = JSON.parse(dec.decode(pkt.slice(0,nl)));
    if(parsed.t!== 'file-chunk' || parsed.len!==5) throw new Error('Framing parse failed');
    log('✓ Packet framing');

    $('#passphrase').value = 'unit-test-pass';
    await deriveRoomKey();
    if(!roomKeyRaw || roomKeyRaw.length!==32) throw new Error('Key derivation failed');
    log('✓ Key derivation');

    $('#testStatus').textContent='PASS';
  }catch(e){
    $('#testStatus').textContent='FAIL';
    const msg = (e && e.stack) ? e.stack : String(e);
    const el=$('#testLog'); el.textContent += 'ERROR: '+msg+"\n";
  }
};

// Init default key
deriveRoomKey();
</script>
</body>
</html>
